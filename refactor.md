  - Warstwowanie i DI – wydziel trzy moduły (data, domain, presentation) z repozytoriami i use-case’ami; przenieś logikę sieciową z serwisów do repo (EventRepository, UserRepository, FavoriteRepository), a UI niech zależy tylko od use-case’ów. Wprowadź zautomatyzowany DI (np. get_it + injectable) zamiast ręcznych singletonów w Provider.
  - Stan i prezentacja – zastąp ChangeNotifier nowocześniejszym podejściem (Riverpod/Bloc/Cubit), z immutable state oraz sealed klasami dla loading/success/error. Widgety mapy, listy i panelu użytkownika ogranicz do renderowania, a logikę (snackbary, centra kamery, nawigacja) przenieś do dedykowanych controller/viewmodel.
  - Modele i serializacja – wprowadź DTO + mappery (EventDto → Event, UserDto → User), użyj freezed/json_serializable dla generacji klas, copyWith, == i solidnej obsługi nulli. Obecny mix EventEntity/EventDetails uproś do jednego domenowego modelu plus adaptery do UI.
  - Obsługa wyników i błędów – zastąp bool/null przez Result<Success, Failure> (lub sealed AuthState), aby UI otrzymywał spójne informacje o błędach i mógł wyświetlać odpowiednie komunikaty. Rozbuduj ErrorHandler i logowanie zamiast rozproszonych developer.log.
  - Autoryzacja i storage – zaimplementuj brakujące metody (SecureStorageService.saveEmail), zapewnij kasowanie tokenów w logout, rozważ odświeżanie tokenu przez dedykowany use-case i repozytorium auth. Ustandaryzuj zapisy ustawień dev-mode w jednym interfejsie (np. AppPreferences).
  - Konfiguracja i certyfikaty – rozbuduj layer konfiguracji: flavor-config/.env, obsługa wyjątków przy ładowaniu certyfikatu, fallback na standardowy kontekst w razie braku pliku. Dodaj możliwość wymuszenia innych endpointów (staging/prod) z poziomu dev ustawień.
  - UI/Design System – rozwiń MeetAppTheme o kompletne TextTheme, ComponentThemeData, tryb ciemny i centralny katalog komponentów (AppButton, AppCard, AppBadge). Zastąp rozproszone style ich wariantami i przygotuj dedykowane widgety dla powtarzalnych wzorców (np. list item wydarzenia).
  - Mapy i wydajność – utrzymuj instancję GoogleMap niezależnie od FutureBuilder, aktualizuj Set<Marker> przez kontroler. Zastanów się nad cachingiem/geohash, aby uniknąć pełnego odświeżania przy każdym ruchu kamery.
  - Testy i automatyzacja – dodaj testy jednostkowe (repozytoria, use-case’y, mappery) i widget/goldeny dla krytycznych ekranów. W CI uruchamiaj flutter test, analizę (dart analyzer) i format. Możesz też dodać screenshot testy dla mapy/listy.
  - Dalsze usprawnienia – rozważ integrację z feature flagami (np. nowy ekran serii wydarzeń), monitoringiem błędów (Sentry/Firebase Crashlytics) oraz analityką zdarzeń użytkownika, aby lepiej reagować na problemy w produkcji.
